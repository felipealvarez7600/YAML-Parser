package pt.isel

import org.cojen.maker.ClassMaker
import org.cojen.maker.Variable
import pt.isel.annotations.YamlArg
import pt.isel.annotations.YamlConvert
import java.lang.reflect.ParameterizedType
import kotlin.reflect.KClass
import kotlin.reflect.full.createInstance

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any>(
    private val type: KClass<T>,
    private val nrOfInitArgs: Int)
: AbstractYamlParser<T>(type) {

    companion object {
        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "YamlParser${type.simpleName}$nrOfInitArgs"
        }
        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(KClass::class.java, Integer::class.java)
                    .newInstance(type, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    fun<T : Any> yamlParser(type: Class<T>) = YamlParserCojen.yamlParser(type.kotlin)

    fun iterateListToConvert(list : Any, parser: Any): List<Any>{
        return (list as List<Map<String, Any>>).map {
            (parser as YamlParserCojen<*>).newInstance(it)
        }
    }

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    private fun buildYamlParser(): ClassMaker {
        val className = parserName(type, nrOfInitArgs)
        val classMaker = ClassMaker.begin(className).public_().extend(YamlParserCojen::class.java).public_()

        classMaker.addField(KClass::class.java, "type").private_().final_()
        classMaker.addField(Integer::class.java, "nrOfInitArgs").private_().final_()

        val constructor = classMaker.addConstructor(KClass::class.java, Integer::class.java).public_()
        constructor.field("type").set(constructor.param(0))
        constructor.field("nrOfInitArgs").set(constructor.param(1))
        constructor.invokeSuperConstructor(constructor.param(0), constructor.param(1))

        val newInstanceMethod = classMaker.addMethod(Any::class.java, "newInstance", Map::class.java).public_().override()
        val args = newInstanceMethod.param(0)

        val constructorArgs = mutableListOf<Variable>()
        if (nrOfInitArgs == 0) {
            val primitiveValue = args.invoke("get", "#")
            val newValue = when (type.java) {
                Int::class.java, Long::class.java, Double::class.java,
                Float::class.java, Short::class.java, Byte::class.java,
                Boolean::class.java, Char::class.java -> {
                    newInstanceMethod.`var`(type.java)
                        .invoke("valueOf", primitiveValue.cast(String::class.java))
                }
                else -> primitiveValue.cast(String::class.java)
            }
            newInstanceMethod.return_(newValue)
            return classMaker
        }
        val parameters = type.java.constructors.first { it.parameters.size == nrOfInitArgs }.parameters
        parameters.forEach { param ->
            val paramName = if (param.isAnnotationPresent(YamlArg::class.java)) param.getAnnotation(YamlArg::class.java).paramName else param.name
            val value = args.invoke("get", paramName)
            val newValue = when {
                param.isAnnotationPresent(YamlConvert::class.java) -> {
                    val yamlConvertAnnotation = param.getAnnotation(YamlConvert::class.java)
                    val parserClass = yamlConvertAnnotation.parser
//                    private fun instantiateCustomParser(parserClass: KClass<out Any>): YamlAny {
//                        return when (parserClass) {
//                            YamlAny::class -> YamlAny()
//                            else -> throw IllegalArgumentException("Unknown custom parser class: $parserClass")
//                        }
//                    }
                    val parser = instantiateCustomParser(parserClass)
                    val parserConvert = newInstanceMethod.`var`(parser)
                        .invoke("convert", value.cast(String::class.java), paramName)
                    //para corrigir->>>
                    // parserInstance.convert(value.toString(), paramName)
                }
                param.type == Int::class.java || param.type == Long::class.java || param.type == Double::class.java || param.type == Float::class.java || param.type == Short::class.java || param.type == Byte::class.java || param.type == Boolean::class.java || param.type == Char::class.java -> {
                    newInstanceMethod.`var`(param.type)
                        .invoke("valueOf", value.cast(String::class.java))
                }
                param.type == String::class.java -> value.cast(String::class.java)
                param.type == List::class.java -> {
                    val listType = param.parameterizedType as ParameterizedType
                    val elementType = listType.actualTypeArguments[0]
                    val yamlParserNew = newInstanceMethod.invoke("yamlParser", elementType)
                    newInstanceMethod.invoke("iterateListToConvert", value, yamlParserNew)
                }
                else -> {
                    val classifier = param.type
                    newInstanceMethod.invoke("yamlParser", classifier).invoke("newInstance", value.cast(Map::class.java)).cast(classifier)
                }
            }
            constructorArgs.add(newValue as Variable)
        }

        val constructorCall = newInstanceMethod.new_(type.java, *constructorArgs.toTypedArray())
        newInstanceMethod.return_(constructorCall)
        return classMaker
    }

    private fun instantiateCustomParser(parserClass: KClass<out Any>): YamlAny {
        return when (parserClass) {
            YamlAny::class -> YamlAny()
            else -> throw IllegalArgumentException("Unknown custom parser class: $parserClass")
        }
    }

}

